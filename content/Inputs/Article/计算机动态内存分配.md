---
aliases: []
created_date: 2023-08-25 09:38
draft: false
summary: ''
tags:
- dev
---

虽然可以使用低级的 mmap 和 munmap 函数来创建和删除虚拟内存的区域，但是 C 程序员还是会觉得当运行时需要额外虚拟内存时，用 **动态内存分配器** （dynamic memory allocator）更方便，也有更好的可移植性。

动态内存分配器维护着一个进程的虚拟内存区域，称为 **堆** （heap）（见图 9-33）。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量 brk（读做 “break”），它指向堆的顶部。

![图 9-33 堆|475](Attachments/73fc25bb51725919e355e39a9dad5512_MD5.webp)

分配器将堆视为一组不同大小的 **块** （block）的集合来维护。每个块就是一个连续的虚拟内存片（chunk），要么是 **已分配的** ，要么是 **空闲的** 。已分配的块显式地保留为供应用程序使用。空闲块可用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。

分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。

- **显式分配器** （explicit allocator），要求应用显式地释放任何已分配的块。例如，C 标准库提供一种叫做 malloc 程序包的显式分配器。C 程序通过调用 malloc 函数来. 分配一个块，并通过调用 free 函数来释放一个块。C++ 中的 new 和 delete 操作符与 C 中的 malloc 和 free 相当。
- **隐式分配器** （implicit allocator），另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做 **垃圾收集器** （garbage collector），而自动释放未使用的已分配的块的过程叫做 **垃圾收集** （garbage collection）。例如，诸如 Lisp、ML 以及 Java 之类的高级语言就依赖垃圾收集来释放已分配的块。
	- [JVM 知识总结#1 垃圾收集](JVM%20知识总结.md#1%20垃圾收集)

## 分配器的要求

- **处理任意请求序列。** 一个应用可以有任意的分配请求和释放请求序列，只要满足约束条件：每个释放请求必须对应于一个当前已分配块，这个块是由一个以前的分配请求获得的。因此，分配器不可以假设分配和释放请求的顺序。例如，分配器不能假设所有的分配请求都有相匹配的释放请求，或者有相匹配的分配和空闲请求是嵌套的。
- **立即响应请求。** 分配器必须立即响应分配请求。因此，不允许分配器为了提高性能重新排列或者缓冲请求。
- **只使用堆。** 为了使分配器是可扩展的，分配器使用的任何非标量数据结构都必须保存在堆里。
- **对齐块（对齐要求）。** 分配器必须对齐块，使得它们可以保存任何类型的数据对象。
- **不修改已分配的块。** 分配器只能操作或者改变空闲块。特别是，一旦块被分配了，就不允许修改或者移动它了。因此，诸如压缩已分配块这样的技术是不允许使用的。