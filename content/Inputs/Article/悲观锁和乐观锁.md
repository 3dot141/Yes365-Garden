---
aliases: []
created_date: 2023-08-24 16:13
draft: false
summary: ''
tags:
- dev
---

## 一、何为悲观锁、乐观锁

### 1、悲观锁

顾名思义，就是比较悲观的锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（ **共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程** ）。传统的关系型数据库里边就用到了很多这种 **锁机制** ，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java 中 `synchronized` 和 `ReentrantLock` 等独占锁就是悲观锁思想的实现。

### 2、乐观锁

反之，总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和 CAS 算法实现。 **乐观锁适用于多读的应用类型，这样可以提高吞吐量** ，像数据库提供的类似于 **write_condition 机制** ，其实都是提供的乐观锁。在 Java 中 `java.util.concurrent.atomic` 包下面的原子变量类就是使用了乐观锁的一种实现方式 **CAS** 实现的。

## 二、悲观锁和乐观锁应用场景

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像 **乐观锁适用于写比较少的情况下（多读场景）** ，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以 **一般多写的场景下用悲观锁就比较合适。**  

## 三、实现方式

上面其实已经说了悲观锁的实现方式了，即 `synchronized` 和 `ReentrantLock`。所以下面主要说说乐观锁的实现方式。主要有两种方式：

### 1.版本号机制

一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数，当数据被修改时，version 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。就是通过 version 版本号作为一个标识，标识这个字段所属的数据是否被改变。

如下面的 sql 语句：

```null
update table set x=x+1, version=version+1 where id=#{id} and version=#{version};  
```

### 2.CAS算法：

即 **compare and swap（比较与交换）** ，是一种有名的 **无锁算法** 。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。 **CAS 算法** 涉及到三个操作数

- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B

当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个 **自旋操作** ，即 **不断的重试** 。

## 四、乐观锁的缺点：

### 1 ABA 问题

如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。这个问题被称为 CAS 操作的 **"ABA"问题。** 

JDK 1.5 以后的 `AtomicStampedReference 类` 就提供了此种能力，其中的 `compareAndSet 方法` 就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

### 2 循环时间长开销大  

 **自旋 CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给 CPU 带来非常大的执行开销。**  如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。

### 3 只能保证一个共享变量的原子操作

CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。但是从 JDK 1.5开始，提供了 `AtomicReference类` 来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用 `AtomicReference类` 把多个共享变量合并成一个共享变量来操作。