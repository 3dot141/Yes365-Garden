---
aliases: []
created_date: 2023-08-23 15:31
draft: false
summary: ''
tags:
- dev
---

[消息链路拆分最佳实践：钉钉审批异步链路重构](https://mp.weixin.qq.com/s?__biz=MzIzOTU0NTQ0MA==&mid=2247532235&idx=1&sn=7ab178033108c3f863727374cc62ebc8&chksm=e92a43c4de5dcad23d2ca7ce3c0c580fa32ce94e3667430627aa5c69f08b08088a7753141df9&mpshare=1&scene=1&srcid=03044YLLweMA2Cyxpf8CB0GV&sharer_sharetime=1677924115038&sharer_shareid=5e15907b71d950595664f00fbb2d84df#rd)

消息队列在设计之初就给业务规划好了一条康庄大道：

- 主业务链路作为 Producer 发出消息
- 数十个甚至更多 Consumer 订阅该消息，分别执行自己快速且幂等的原子逻辑

![图片|500](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKeicPyWZsvlOKibRpRn4VBRhVXZel54aHb38CyIrlgAbVYHsgNCqdaeU4XfzYJR8T3kkGjQibLEq8HQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

在这种设计下，每个订阅者的逻辑相互隔离，互不影响；能够独立地重试，保证自己的一致性。

现实并不总像上面幻想的那样，随着业务发展常会出现一些 “大泥球” 消费者。

以钉钉审批为例，为了优化产品体验，在审批单发起后，还要消费审批单发起消息，异步做一系列的事情，比如发消息通知，同步搜索引擎，更新提示红点等等，这些功能随着产品迭代只会越叠越多，最后成为一个同时做十几件事情的 “大泥球” 消费者。

![图片|525](https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKeicPyWZsvlOKibRpRn4VBRhslg88x9ZERiaPFEUsqb36T5ErCpmoMjc95O3Yql1mMohHpGV7pL6zOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

大泥球 Consumer 对系统和用户都有巨大的损害：

- 逻辑相互影响，修改风险高；
- 链路脆弱，容易中断，一个调用失败，后续所有逻辑将不会执行；  
- 没有重试：大泥球无法做到原子和幂等，整体重试代价太大，所以直接异步执行放弃重试
- 消息队列引以为傲的重试功能反而会成为故障的温床，导致雪崩。  
- 为什么不直接把大泥球拆分成前面的多个 Consumer 呢？这确实也是一种方案，但是对于大泥球 Consumer，可能会拆出几十个 Consumer，这会导致非常严重的读扩散。举个例子，审批单发起的消息中只含有审批单的 id，内容需要从数据库反查，原本在“大泥球”中，只需要查询一次就复用，而拆分后可能要多查几十次。这还只是众多扩散问题的其中一个，如果为了治理大泥球，却加重了扩散问题，就得不偿失了。

# 结论

1、将堆砌在一起的逻辑 **拆分** 成一个个业务 Listener 类（详见 “朴素的拆分想法” 章节）；

2、当有业务 Listener 失败时，可以实现失败业务 **精准重试**，而不是粗暴地全部重试（详见 “精准重试” 章节）；

3、**高性能** 地构建 Listener 的统一上下文，降低读扩散，并且避免其随着迭代腐化（详解 “统一上下文” 章节）；

4、最后，本文的实践不需要额外的存储，也不需要建立额外的 Consumer，原来的基础设施可以直接复用；