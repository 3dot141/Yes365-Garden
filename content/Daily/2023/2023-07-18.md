---
aliases: []
created_date: 2023-07-18 00:00
draft: false
summary: ''
tags:
- daily
---

```dataviewjs

const currentPage = dv.current().file;
const dailyPages = dv.pages('"Daily"').sort(k=>k.file.name, "asc");
const currentPageName = currentPage.name;
const index = dailyPages.findIndex((e) => {return e.file.name === currentPageName});
if (index < 1) {
	dv.table(["File", "Created", "Size"],[]);
} else {
	const lastIndex = index - 1;
	const lastPage = dailyPages[lastIndex].file;
	const allPages = dv.pages().values;
	const searchPages = [];
	
	const lastTime = dv.parse(lastPage.name);
	const currentTime = dv.parse(currentPage.name);

	for (let page of allPages) {
		const pageFile = page.file;
		if (pageFile.cday > lastTime && pageFile.cday <= currentTime) {
		  searchPages.push(pageFile);
		}
	}
	dv.table(["File", "Created", "Size"], searchPages.sort((a, b) => a.ctime > b.ctime ? 1 : -1).map(b => [b.link, b.ctime, b.size]));
}

```

# 序列化框架-Fury

> [比JDK最高快170倍，蚂蚁集团开源高性能多语言序列化框架Fury](https://mp.weixin.qq.com/s/QHdmOjBpfvCO7cBYTxvXJg)

Fury 是一个基于 JIT 动态编译和零拷贝的多语言序列化框架，提供极致的性能和易用性：

* 支持主流编程语言 **Java/ Python/ C++/ Golang/ JavaScript**，其它语言可轻易扩展；
* 统一的多语言序列化核心能力：
	* **高度优化的序列化原语**；
	* **Zero-Copy 序列化** 支持，支持 Out of band 序列化协议，支持堆外内存读写；
	* 基于 **JIT 动态编辑** 技术在运行时**异步多线程自动生成序列化代码优化性能**，增加方法内联、代码缓存和消除死代码，减少虚方法调用 / 条件分支 /Hash 查找 / 元数据写入 / 内存读写等，**提供相比别的序列化框架最高 170 倍的性能**；
* 多协议支持：兼顾动态序列化的灵活性和易用性，以及静态序列化的跨语言能力。
	* Java 序列化：
		* 无缝替代 JDK/Kryo/Hessian，无需修改任何代码，但提供最高 170x 的性能，可以大幅提升高性能场景 **RPC 调用、数据传输和对象持久化效率**；
		* 100% 兼容 JDK 序列化，原生支持 JDK 自定义序列化方法 writeObject/ readObject/ writeReplace/ readResolve/ readObjectNoData
	* 跨语言对象图序列化：
		* 多语言 / 跨语言**自动序列化任意对象**，无需创建 IDL 文件、手动编译 schema 生成代码以及将对象转换为中间格式；
		* 多语言 / 跨语言**自动序列化共享引用和循环引用**，不需要关心数据重复或者递归错误；
		* 支持对象类型多态，多个子类型对象可以同时被序列化；
	* 行存序列化：
		* 提供缓存友好的**二进制随机访问行存**格式，支持跳过序列化和部分序列化，适合高性能计算和大规模数据传输场景；
		* 支持和 Arrow 列存自动互转 ;

  
- [万字长文深度解析JDK序列化原理及Fury高度兼容的极致性能实现-阿里云开发者社区](https://developer.aliyun.com/article/1102715)
	- 兼容 JDK 的序列化自定义 writeObject/readObject/writeReplace/readResolve 的对象
- [Fury：一个基于JIT动态编译的高性能多语言原生序列化框架-阿里云开发者社区](https://developer.aliyun.com/article/992485#slide-1)
	- 功能对比

# Gradle ShadowJar

> [ShadowJar-Introduction](https://imperceptiblethoughts.com/shadow/introduction/#benefits-of-shadow)

Shadow is a Gradle plugin for combining a project's dependency classes and resources into a single output Jar. The combined Jar is often referred to a _fat-jar_ or _uber-jar_. Shadow utilizes [`JarInputStream`](https://docs.oracle.com/javase/8/docs/api/java/util/jar/JarInputStream.html) and [`JarOutputStream`](https://docs.oracle.com/javase/8/docs/api/java/util/jar/JarOutputStream.html) to efficiently process dependent libraries into the output jar without incurring the I/O overhead of expanding the jars to disk.

组合不同的 class 到一个 Jar 中。

## Gradle ShadowJar 添加 source.jar

The shadow plugin doesn't seem to have a feature of building a fat sources/javadocs jars.  
Below, I provide a few short tasks (`javadocJar` and `sourcesJar`) that will build fat javadoc and source jars. They are linked to be always executed after `shadowJar`. But it has no dependency on the shadow jar plugin.

```java
subprojects {
    apply plugin: 'java'
}

// Must be BELOW subprojects{}
task alljavadoc(type: Javadoc) {
    source subprojects.collect { it.sourceSets.main.allJava }
    classpath = files(subprojects.collect { it.sourceSets.main.compileClasspath })
    destinationDir = file("${buildDir}/docs/javadoc")
}

task javadocJar(type: Jar, dependsOn: alljavadoc) {
    classifier = 'javadoc'
    from alljavadoc.destinationDir
}

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from subprojects.collect { it.sourceSets.main.allSource }
}

shadowJar.finalizedBy javadocJar
shadowJar.finalizedBy sourcesJar
```

Note, the `subprojects` section is **required**, even if you already apply the `java` plugin inside your subprojects.  
Also note, it doesn't include javadocs of the third party libraries your subprojects might depend on. But usually you wouldn't want to do it anyway, probably.

## Maven 添加 source.jar

```xml
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-source-plugin</artifactId>
                <version>2.4</version>
                <configuration>
                    <attach>true</attach>
                </configuration>
            </plugin>
        </plugins>
    </build>
```